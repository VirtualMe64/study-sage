{
  "lessonPlan": {
    "title": "The Pythagorean Theorem: A Visual Journey",
    "objectives": [
      "Introduce the Pythagorean Theorem and its significance in geometry",
      "Visually demonstrate the theorem using geometric constructions",
      "Provide a step-by-step proof using animated squares and triangles",
      "Show real-world applications and problem-solving using the theorem"
    ]
  },
  "sceneFiles": [
    {
      "id": "scene-1",
      "className": "IntroductionToPythagoreanTheoremScene",
      "filename": "introduction_to_pythagorean_theorem.py",
      "code": "from manim import *\n\nclass IntroductionToPythagoreanTheoremScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Introduction to the Pythagorean Theorem\", font_size=42)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        self.wait(0.5)\n\n        # Right triangle vertices\n        A = np.array([-2, -1, 0])  # left-bottom\n        B = np.array([2, -1, 0])   # right-bottom\n        C = np.array([2, 2, 0])    # top-right\n\n        # Draw triangle\n        triangle = Polygon(A, B, C, color=BLUE, stroke_width=6)\n        self.play(Create(triangle))\n        self.wait(0.5)\n\n        # Dots for vertices\n        dot_A = Dot(A, color=WHITE)\n        dot_B = Dot(B, color=WHITE)\n        dot_C = Dot(C, color=WHITE)\n        self.play(FadeIn(dot_A), FadeIn(dot_B), FadeIn(dot_C))\n\n        # Vertex labels\n        label_A = MathTex(r\"A\", font_size=36).next_to(dot_A, DOWN+LEFT, buff=0.15)\n        label_B = MathTex(r\"B\", font_size=36).next_to(dot_B, DOWN+RIGHT, buff=0.15)\n        label_C = MathTex(r\"C\", font_size=36).next_to(dot_C, UP+RIGHT, buff=0.15)\n        self.play(Write(label_A), Write(label_B), Write(label_C))\n        self.wait(0.5)\n\n        # Highlight right angle at B\n        right_angle = RightAngle(Line(B, A), Line(B, C), length=0.3, color=YELLOW)\n        self.play(Create(right_angle))\n        self.wait(0.5)\n\n        # Side labels: a, b, c\n        # a: BC (vertical leg)\n        side_a = MathTex(r\"a\", font_size=36, color=GREEN).move_to((B + C)/2 + np.array([0.3, 0, 0]))\n        # b: AB (horizontal leg)\n        side_b = MathTex(r\"b\", font_size=36, color=RED).move_to((A + B)/2 + np.array([0, -0.3, 0]))\n        # c: AC (hypotenuse)\n        side_c = MathTex(r\"c\", font_size=36, color=ORANGE).move_to((A + C)/2 + np.array([-0.3, 0.3, 0]))\n        self.play(Write(side_a), Write(side_b), Write(side_c))\n        self.wait(0.5)\n\n        # Highlight sides with colored lines\n        leg_a = Line(B, C, color=GREEN, stroke_width=10)\n        leg_b = Line(A, B, color=RED, stroke_width=10)\n        hypotenuse = Line(A, C, color=ORANGE, stroke_width=10)\n        self.play(Create(leg_a), Create(leg_b), Create(hypotenuse))\n        self.wait(0.5)\n\n        # Fade out colored lines to keep triangle clear\n        self.play(FadeOut(leg_a), FadeOut(leg_b), FadeOut(hypotenuse))\n        self.wait(0.25)\n\n        # Definition text\n        definition = Text(\n            \"A right triangle has one 90Â° angle.\", font_size=32\n        ).to_edge(DOWN)\n        self.play(FadeIn(definition))\n        self.wait(1.2)\n        self.play(FadeOut(definition))\n\n        # Pythagorean Theorem statement\n        theorem_text = Text(\"Pythagorean Theorem:\", font_size=36)\n        theorem_text.next_to(triangle, RIGHT, buff=1.2)\n        formula = MathTex(r\"a^2 + b^2 = c^2\", font_size=54)\n        formula.next_to(theorem_text, DOWN, buff=0.4)\n        self.play(FadeIn(theorem_text))\n        self.wait(0.3)\n        self.play(Write(formula))\n        self.wait(1.2)\n\n        # Highlight formula terms to match triangle sides\n        self.play(\n            formula[0][0].animate.set_color(GREEN),   # a\n            formula[0][4].animate.set_color(RED),     # b\n            formula[0][8].animate.set_color(ORANGE),  # c\n            run_time=1\n        )\n        self.wait(1.2)\n\n        # End\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.wait(0.5)\n",
      "validationResults": {
        "syntaxValid": true,
        "manimCompatible": true,
        "warnings": [],
        "suggestions": []
      }
    },
    {
      "id": "scene-2",
      "className": "GeometricVisualizationOfTheorem",
      "filename": "geometric_visualization_of_the_theorem.py",
      "code": "from manim import *\n\nclass GeometricVisualizationOfTheorem(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Geometric Visualization of the Theorem\", font_size=40)\n        self.play(FadeIn(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Define triangle vertices\n        A = LEFT * 3 + DOWN * 1\n        B = RIGHT * 2 + DOWN * 1\n        C = LEFT * 3 + UP * 2\n        \n        # Draw the right triangle\n        triangle = Polygon(A, B, C, color=WHITE, stroke_width=4)\n        self.play(Create(triangle))\n        self.wait(0.5)\n        \n        # Mark vertices\n        label_A = MathTex(r\"A\", font_size=36).next_to(A, LEFT+DOWN, buff=0.2)\n        label_B = MathTex(r\"B\", font_size=36).next_to(B, RIGHT+DOWN, buff=0.2)\n        label_C = MathTex(r\"C\", font_size=36).next_to(C, LEFT+UP, buff=0.2)\n        self.play(FadeIn(label_A), FadeIn(label_B), FadeIn(label_C))\n        self.wait(0.5)\n        \n        # Draw squares on each side\n        # Side AB (base)\n        ab_vec = B - A\n        ab_len = np.linalg.norm(ab_vec)\n        ab_dir = ab_vec / ab_len\n        ab_perp = np.array([-ab_dir[1], ab_dir[0], 0])\n        ab_square = Polygon(\n            A,\n            B,\n            B + ab_perp * ab_len,\n            A + ab_perp * ab_len,\n            color=BLUE, fill_color=BLUE, fill_opacity=0.5, stroke_width=4\n        )\n        \n        # Side BC (hypotenuse)\n        bc_vec = C - B\n        bc_len = np.linalg.norm(bc_vec)\n        bc_dir = bc_vec / bc_len\n        bc_perp = np.array([-bc_dir[1], bc_dir[0], 0])\n        bc_square = Polygon(\n            B,\n            C,\n            C + bc_perp * bc_len,\n            B + bc_perp * bc_len,\n            color=GREEN, fill_color=GREEN, fill_opacity=0.5, stroke_width=4\n        )\n        \n        # Side AC (height)\n        ac_vec = C - A\n        ac_len = np.linalg.norm(ac_vec)\n        ac_dir = ac_vec / ac_len\n        ac_perp = np.array([ac_dir[1], -ac_dir[0], 0])\n        ac_square = Polygon(\n            A,\n            C,\n            C + ac_perp * ac_len,\n            A + ac_perp * ac_len,\n            color=RED, fill_color=RED, fill_opacity=0.5, stroke_width=4\n        )\n        \n        # Animate construction of squares one by one\n        self.play(Create(ab_square))\n        self.wait(0.5)\n        self.play(Create(ac_square))\n        self.wait(0.5)\n        self.play(Create(bc_square))\n        self.wait(1)\n        \n        # Add labels for sides and squares\n        ab_label = MathTex(r\"a\", font_size=36, color=BLUE).next_to((A+B)/2, DOWN, buff=0.3)\n        ac_label = MathTex(r\"b\", font_size=36, color=RED).next_to((A+C)/2, LEFT, buff=0.3)\n        bc_label = MathTex(r\"c\", font_size=36, color=GREEN).next_to((B+C)/2, UP+RIGHT, buff=0.3)\n        \n        ab_sq_label = MathTex(r\"a^2\", font_size=36, color=BLUE).move_to(ab_square.get_center())\n        ac_sq_label = MathTex(r\"b^2\", font_size=36, color=RED).move_to(ac_square.get_center())\n        bc_sq_label = MathTex(r\"c^2\", font_size=36, color=GREEN).move_to(bc_square.get_center())\n        \n        self.play(FadeIn(ab_label), FadeIn(ac_label), FadeIn(bc_label))\n        self.wait(0.5)\n        self.play(FadeIn(ab_sq_label), FadeIn(ac_sq_label), FadeIn(bc_sq_label))\n        self.wait(1)\n        \n        # Visually compare the areas: group the two smaller squares and move them near the large one\n        small_squares = VGroup(ab_square, ac_square, ab_sq_label, ac_sq_label)\n        large_square = VGroup(bc_square, bc_sq_label)\n        \n        # Highlight the large square\n        highlight_rect = Rectangle(\n            width=bc_square.get_width()+0.2,\n            height=bc_square.get_height()+0.2,\n            stroke_color=YELLOW,\n            stroke_width=6\n        ).move_to(bc_square.get_center())\n        self.play(Create(highlight_rect))\n        self.wait(0.5)\n        \n        # Move the two small squares together near the large square for visual comparison\n        self.play(\n            small_squares.animate.shift(RIGHT*3),\n            run_time=1.5\n        )\n        self.wait(0.5)\n        \n        # Fade out the triangle and side labels to focus on the squares\n        self.play(\n            FadeOut(triangle),\n            FadeOut(label_A),\n            FadeOut(label_B),\n            FadeOut(label_C),\n            FadeOut(ab_label),\n            FadeOut(ac_label),\n            FadeOut(bc_label),\n            run_time=1\n        )\n        self.wait(0.5)\n        \n        # Show the Pythagorean Theorem equation\n        equation = MathTex(r\"a^2 + b^2 = c^2\", font_size=48)\n        equation.next_to(large_square, DOWN, buff=1)\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Animate the small squares merging into the large square (visual sum)\n        self.play(\n            ab_square.animate.move_to(bc_square.get_center() + LEFT*0.7 + DOWN*0.7).scale(0.7),\n            ac_square.animate.move_to(bc_square.get_center() + RIGHT*0.7 + UP*0.7).scale(0.7),\n            ab_sq_label.animate.move_to(bc_square.get_center() + LEFT*0.7 + DOWN*0.7),\n            ac_sq_label.animate.move_to(bc_square.get_center() + RIGHT*0.7 + UP*0.7),\n            run_time=1.5\n        )\n        self.wait(1)\n        \n        # Fade out everything except the equation\n        self.play(\n            FadeOut(ab_square),\n            FadeOut(ac_square),\n            FadeOut(bc_square),\n            FadeOut(ab_sq_label),\n            FadeOut(ac_sq_label),\n            FadeOut(bc_sq_label),\n            FadeOut(highlight_rect),\n            run_time=1\n        )\n        self.wait(0.5)\n        \n        # Emphasize the equation\n        self.play(equation.animate.scale(1.3).set_color(YELLOW))\n        self.wait(2)\n",
      "validationResults": {
        "syntaxValid": true,
        "manimCompatible": true,
        "warnings": [],
        "suggestions": []
      }
    },
    {
      "id": "scene-3",
      "className": "ProofByRearrangementDissectionScene",
      "filename": "proof_by_rearrangement_dissection.py",
      "code": "from manim import *\n\nclass ProofByRearrangementDissectionScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Proof by Rearrangement (Dissection Proof)\", font_size=40)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n\n        # Side lengths\n        a = 2.5\n        b = 1.5\n        c = (a ** 2 + b ** 2) ** 0.5\n\n        # Draw the right triangle\n        triangle = Polygon(\n            ORIGIN,\n            a * RIGHT,\n            a * RIGHT + b * UP,\n            color=BLUE,\n            fill_opacity=0.3,\n            stroke_width=4\n        )\n        self.play(Create(triangle))\n        self.wait(0.5)\n\n        # Label sides\n        label_a = MathTex(r\"a\", font_size=36).next_to(0.5 * a * RIGHT, DOWN)\n        label_b = MathTex(r\"b\", font_size=36).next_to(a * RIGHT + 0.5 * b * UP, RIGHT)\n        label_c = MathTex(r\"c\", font_size=36).next_to(0.5 * (a * RIGHT + b * UP), UL, buff=0.2)\n        self.play(Write(label_a), Write(label_b), Write(label_c))\n        self.wait(0.5)\n\n        # Duplicate and arrange 4 triangles to form a square of side (a+b)\n        tri1 = triangle.copy()\n        tri2 = triangle.copy().rotate(PI/2, about_point=ORIGIN)\n        tri3 = triangle.copy().rotate(PI, about_point=ORIGIN)\n        tri4 = triangle.copy().rotate(3*PI/2, about_point=ORIGIN)\n        group_tris = VGroup(tri1, tri2, tri3, tri4)\n        group_tris.move_to(LEFT * 3)\n        self.play(\n            ReplacementTransform(triangle, tri1),\n            FadeIn(tri2), FadeIn(tri3), FadeIn(tri4),\n            run_time=1.5\n        )\n        self.wait(0.5)\n\n        # Draw the large square (side a+b)\n        square_side = a + b\n        big_square = Square(side_length=square_side, color=YELLOW, stroke_width=4)\n        big_square.move_to(tri1.get_center())\n        self.play(Create(big_square), run_time=1)\n        self.wait(0.5)\n\n        # Show the two inner squares (a^2 and b^2)\n        # Small square (side b)\n        small_square = Square(side_length=b, color=GREEN, fill_opacity=0.4, stroke_width=3)\n        small_square.move_to(big_square.get_corner(DL) + b/2 * (RIGHT + UP))\n        # Medium square (side a)\n        medium_square = Square(side_length=a, color=RED, fill_opacity=0.4, stroke_width=3)\n        medium_square.move_to(big_square.get_corner(UR) - a/2 * (RIGHT + UP))\n        self.play(FadeIn(small_square), FadeIn(medium_square))\n        self.wait(1)\n\n        # Label the squares\n        label_a2 = MathTex(r\"a^2\", font_size=36).move_to(medium_square.get_center())\n        label_b2 = MathTex(r\"b^2\", font_size=36).move_to(small_square.get_center())\n        self.play(Write(label_a2), Write(label_b2))\n        self.wait(1)\n\n        # Highlight the area equation\n        eq1 = MathTex(r\"a^2 + b^2 = ?\", font_size=44).to_edge(DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n\n        # Rearrangement: Move triangles to form a square of side c\n        # Calculate the position for the c-square\n        c_square = Square(side_length=c, color=ORANGE, fill_opacity=0.4, stroke_width=4)\n        c_square.move_to(RIGHT * 3)\n        label_c2 = MathTex(r\"c^2\", font_size=36).move_to(c_square.get_center())\n\n        # Triangles for rearrangement\n        tri1_new = triangle.copy().move_to(c_square.get_corner(DL))\n        tri2_new = triangle.copy().rotate(PI/2).move_to(c_square.get_corner(DR))\n        tri3_new = triangle.copy().rotate(PI).move_to(c_square.get_corner(UR))\n        tri4_new = triangle.copy().rotate(3*PI/2).move_to(c_square.get_corner(UL))\n        new_tris = VGroup(tri1_new, tri2_new, tri3_new, tri4_new)\n\n        # Animate triangles moving to new positions\n        self.play(\n            AnimationGroup(\n                tri1.animate.move_to(tri1_new.get_center()),\n                tri2.animate.move_to(tri2_new.get_center()),\n                tri3.animate.move_to(tri3_new.get_center()),\n                tri4.animate.move_to(tri4_new.get_center()),\n                lag_ratio=0.1,\n                run_time=2\n            )\n        )\n        self.wait(0.5)\n\n        # Fade out the (a+b)^2 square and inner squares\n        self.play(FadeOut(big_square), FadeOut(small_square), FadeOut(medium_square), FadeOut(label_a2), FadeOut(label_b2))\n        self.wait(0.5)\n\n        # Show the c^2 square\n        self.play(FadeIn(c_square), FadeIn(label_c2))\n        self.wait(1)\n\n        # Update the equation\n        eq2 = MathTex(r\"a^2 + b^2 = c^2\", font_size=44).to_edge(DOWN)\n        self.play(ReplacementTransform(eq1, eq2))\n        self.wait(1.5)\n\n        # Highlight the equality visually\n        highlight_rect = SurroundingRectangle(eq2, color=YELLOW, buff=0.2)\n        self.play(Create(highlight_rect), run_time=0.7)\n        self.wait(2)\n\n        # End scene\n        self.play(FadeOut(VGroup(eq2, highlight_rect, c_square, label_c2, tri1, tri2, tri3, tri4)))\n        self.wait(0.5)\n",
      "validationResults": {
        "syntaxValid": true,
        "manimCompatible": true,
        "warnings": [],
        "suggestions": []
      }
    },
    {
      "id": "scene-4",
      "className": "ApplicationsAndExampleProblemScene",
      "filename": "applications_and_example_problem_scene.py",
      "code": "from manim import *\n\nclass ApplicationsAndExampleProblemScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Applications and Example Problem\", font_size=44)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n\n        # Real-world scenario description\n        scenario = Text(\n            \"A ladder leans against a wall.\\nThe base is 6 m from the wall, and the top reaches 8 m high.\\nHow long is the ladder?\",\n            font_size=28\n        )\n        scenario.next_to(title, DOWN, buff=0.6)\n        self.play(FadeIn(scenario, shift=DOWN))\n        self.wait(2)\n\n        # Draw the triangle (wall, ground, ladder)\n        ground = Line([-3, -2, 0], [2, -2, 0], color=GRAY)\n        wall = Line([2, -2, 0], [2, 2, 0], color=GRAY)\n        ladder = Line([-3, -2, 0], [2, 2, 0], color=BLUE, stroke_width=8)\n        triangle = VGroup(ground, wall, ladder)\n        self.play(Create(ground), Create(wall))\n        self.play(Create(ladder))\n        self.wait(0.5)\n\n        # Add labels for sides\n        base_label = MathTex(r\"6\\ \\text{m}\", font_size=32)\n        base_label.next_to(ground, DOWN, buff=0.2)\n        height_label = MathTex(r\"8\\ \\text{m}\", font_size=32)\n        height_label.next_to(wall, RIGHT, buff=0.2)\n        hyp_label = MathTex(r\"x\", font_size=36, color=YELLOW)\n        hyp_label.next_to(ladder, LEFT, buff=0.2)\n        self.play(Write(base_label), Write(height_label), Write(hyp_label))\n        self.wait(1)\n\n        # Highlight the unknown (ladder)\n        self.play(ladder.animate.set_color(YELLOW), hyp_label.animate.scale(1.2))\n        self.wait(0.5)\n\n        # Show the Pythagorean Theorem\n        theorem = MathTex(r\"x^2 = 6^2 + 8^2\", font_size=40)\n        theorem.next_to(triangle, RIGHT, buff=1.2)\n        self.play(Write(theorem))\n        self.wait(1)\n\n        # Step 1: Calculate squares\n        step1 = MathTex(r\"x^2 = 36 + 64\", font_size=40)\n        step1.next_to(theorem, DOWN, buff=0.5)\n        self.play(Write(step1))\n        self.wait(0.7)\n\n        # Step 2: Add\n        step2 = MathTex(r\"x^2 = 100\", font_size=40)\n        step2.next_to(step1, DOWN, buff=0.5)\n        self.play(Write(step2))\n        self.wait(0.7)\n\n        # Step 3: Take square root\n        step3 = MathTex(r\"x = 10\", font_size=44, color=YELLOW)\n        step3.next_to(step2, DOWN, buff=0.5)\n        self.play(Write(step3))\n        self.wait(1)\n\n        # Highlight the answer on the triangle\n        answer_label = MathTex(r\"10\\ \\text{m}\", font_size=36, color=YELLOW)\n        answer_label.move_to(hyp_label.get_center())\n        self.play(ReplacementTransform(hyp_label, answer_label))\n        self.play(ladder.animate.set_color(GREEN))\n        self.wait(1)\n\n        # Final summary\n        summary = Text(\"The ladder is 10 meters long!\", font_size=36, color=GREEN)\n        summary.next_to(triangle, DOWN, buff=1.2)\n        self.play(FadeIn(summary, shift=UP))\n        self.wait(2)\n",
      "validationResults": {
        "syntaxValid": true,
        "manimCompatible": true,
        "warnings": [],
        "suggestions": []
      }
    }
  ],
  "masterFile": {
    "filename": "master_animation.py",
    "content": "# Master Manim Animation File\n# Generated from AI lesson plan: The Pythagorean Theorem: A Visual Journey\nfrom manim import *\n\nclass MasterExplainerScene(Scene):\n    def construct(self):\n        # Simple title display\n        title = Text(\"The Pythagorean Theorem: A Visual Journey\", font_size=48, color=WHITE)\n        title.to_edge(UP, buff=1)\n\n        # Show title\n        self.play(Write(title), run_time=3)\n        self.wait(2)\n\n        # Fade out\n        self.play(FadeOut(title))\n        self.wait(1)\n\nif __name__ == \"__main__\":\n    # Render the master title scene\n    master = MasterExplainerScene()\n    master.render()\n\n    # Individual scenes should be rendered separately:\n    # python introduction_to_pythagorean_theorem.py\n    # python geometric_visualization_of_the_theorem.py\n    # python proof_by_rearrangement_dissection.py\n    # python applications_and_example_problem_scene.py\n"
  },
  "totalScenes": 4
}